"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CsvFactory = void 0;
var sync_1 = require("csv-parse/sync");
var plainjs_1 = require("@json2csv/plainjs");
var CsvFactory = /** @class */ (function () {
    function CsvFactory() {
    }
    CsvFactory.load = function (dataFilename, csvDelimiter, allowEmptyId) {
        var fs = require('fs');
        var csvData = null;
        if (fs.existsSync(dataFilename)) {
            try {
                var csvDataRaw = fs.readFileSync(dataFilename, 'utf8');
                csvData = (0, sync_1.parse)(csvDataRaw, {
                    columns: true,
                    skip_empty_lines: true,
                    delimiter: csvDelimiter
                });
            }
            catch (err) {
                console.log("\u001B[0;31mERROR\u001B[0m reading and parsing data file '".concat(dataFilename, "':"));
                console.error(err);
                csvData = null;
                process.exitCode = 1;
            }
            if (csvData) {
                var uniqueIdList_1 = [];
                var uniqueTitleList_1 = [];
                var uniqueNotationList_1 = [];
                var uniqueIdErrors_1 = [];
                var uniqueTitleErrors_1 = [];
                var uniqueNotationErrors_1 = [];
                var fatalError = false;
                var recordNumber_1 = 1;
                var notationPattern_1 = /^([1-9][0-9]*)(\.[1-9][0-9]*)*$/;
                csvData.forEach(function (c) {
                    recordNumber_1 += 1;
                    if (c.id) {
                        if (uniqueIdList_1.includes(c.id)) {
                            uniqueIdErrors_1.push("#".concat(recordNumber_1));
                        }
                        else {
                            uniqueIdList_1.push(c.id);
                        }
                    }
                    else if (!allowEmptyId) {
                        uniqueIdErrors_1.push("#".concat(recordNumber_1));
                    }
                    if (c.notation) {
                        var notationMatches = c.notation.match(notationPattern_1);
                        if (notationMatches) {
                            if (uniqueNotationList_1.includes(c.notation)) {
                                uniqueNotationErrors_1.push("#".concat(recordNumber_1));
                            }
                            else {
                                uniqueNotationList_1.push(c.notation);
                            }
                        }
                        else {
                            uniqueNotationErrors_1.push("#".concat(recordNumber_1));
                        }
                    }
                    if (c.title) {
                        var checkTitleExpression = "".concat(c.notation || '', "-").concat(c.title);
                        if (uniqueTitleList_1.includes(checkTitleExpression)) {
                            uniqueTitleErrors_1.push("#".concat(recordNumber_1));
                        }
                        else {
                            uniqueTitleList_1.push(checkTitleExpression);
                        }
                    }
                    else {
                        uniqueTitleErrors_1.push("#".concat(recordNumber_1));
                    }
                });
                var allNotations = csvData.map(function (c) { return c.notation; }).filter(function (n) { return n && n.length > 0; });
                if (allNotations.length > 0) {
                    if (allNotations.length < csvData.length) {
                        console.log("\u001B[0;31mERROR\u001B[0m Notations must be given all or none in data file '".concat(dataFilename, "'"));
                        fatalError = true;
                    }
                    if (uniqueNotationErrors_1.length > 0) {
                        console.log("\u001B[0;31mERROR\u001B[0m Notations must be unique and valid in data file '".concat(dataFilename, "' (").concat(uniqueNotationErrors_1.join(', '), ")"));
                        fatalError = true;
                    }
                }
                if (uniqueTitleErrors_1.length > 0) {
                    console.log("\u001B[0;31mERROR\u001B[0m Titles must be unique and not empty in data file '".concat(dataFilename, "' (").concat(uniqueTitleErrors_1.join(', '), ")"));
                    fatalError = true;
                }
                if (uniqueIdErrors_1.length > 0) {
                    if (allowEmptyId) {
                        console.log("\u001B[0;31mERROR\u001B[0m IDs must be unique in data file '".concat(dataFilename, "' (").concat(uniqueIdErrors_1.join(', '), ")"));
                    }
                    else {
                        console.log("\u001B[0;31mERROR\u001B[0m IDs must be unique and not empty in data file '".concat(dataFilename, "' (").concat(uniqueIdErrors_1.join(', '), ")"));
                    }
                    fatalError = true;
                }
                if (fatalError) {
                    csvData = null;
                    process.exitCode = 1;
                }
            }
        }
        else {
            console.log("\u001B[0;31mERROR\u001B[0m data file '".concat(dataFilename, "' not found"));
            process.exitCode = 1;
        }
        return csvData;
    };
    CsvFactory.write = function (dataFilename, data, csvDelimiter) {
        var fs = require('fs');
        var returnValue = true;
        var parser = new plainjs_1.Parser({
            fields: ['notation', 'title', 'description', 'id'],
            quote: '',
            delimiter: csvDelimiter
        });
        try {
            var fileContent = parser.parse(data); // .replaceAll(/"/g, '')
            fs.writeFileSync(dataFilename, fileContent);
        }
        catch (err) {
            console.log("\u001B[0;31mERROR\u001B[0m unable to write data file '".concat(dataFilename, "':"));
            console.error(err);
            returnValue = false;
            process.exitCode = 1;
        }
        return returnValue;
    };
    return CsvFactory;
}());
exports.CsvFactory = CsvFactory;
//# sourceMappingURL=csv.factory.js.map