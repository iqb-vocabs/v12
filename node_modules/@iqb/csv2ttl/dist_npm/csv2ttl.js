#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var config_file_factory_1 = require("./config-file.factory");
var csv_factory_1 = require("./csv.factory");
var fs = require('fs');
var data_folder = '.';
if (process.argv[2]) {
    data_folder = "".concat(data_folder, "/").concat(process.argv[2]);
}
function getNotationDeep(notation) {
    return (notation.split(".")).length;
}
var config_data = config_file_factory_1.ConfigFileFactory.load(data_folder);
if (config_data) {
    var output_folder_1 = './dist';
    if (config_data.outDir) {
        output_folder_1 = config_data.outDir;
    }
    var fileList_1 = {};
    fs.readdirSync(data_folder).forEach(function (file) {
        fileList_1[file.toUpperCase()] = "".concat(data_folder, "/").concat(file);
    });
    var csvDelimiter_1 = config_data.csv_delimiter || ';';
    var stout_base_1 = "@prefix dct: <http://purl.org/dc/terms/>.\n" +
        "@prefix skos: <http://www.w3.org/2004/02/skos/core#>. \n" +
        "@prefix n0: <".concat(config_data.base);
    config_data.vocabularies.forEach(function (voc) {
        if (config_data) {
            var voc_filename = fileList_1["".concat(voc.id.toUpperCase(), ".CSV")];
            var header = "".concat(stout_base_1, "/").concat(voc.id, "/#>. \n") +
                "@prefix n1: <".concat(config_data.base, "/").concat(voc.id, "/>. \n\n");
            var out_path = "".concat(output_folder_1, "/").concat(voc.title[0].value.replace(/ /g, "_"), ".ttl");
            var baseUrl = "n0:";
            var footer_1 = "";
            if (voc.description[0].value === "")
                footer_1 = "".concat(baseUrl, "\n") +
                    "\ta skos:ConceptScheme;\n" +
                    "\tdct:creator \"".concat(config_data.creator, "\"@").concat(voc.title[0].lang, ";\n") +
                    "\tdct:title \"".concat(config_data.title[0].value.replace('^', ';'), " - ").concat(voc.title[0].value.replace('^', ';'), "\"@").concat(voc.title[0].lang, ";\n") +
                    "\tskos:hasTopConcept";
            else
                footer_1 = "".concat(baseUrl, "\n") +
                    "\ta skos:ConceptScheme;\n" +
                    "\tdct:creator \"".concat(config_data.creator, "\"@").concat(voc.title[0].lang, ";\n") +
                    "\tdct:title \"".concat(config_data.title[0].value.replace('^', ';'), " - ").concat(voc.title[0].value.replace('^', ';'), "\"@").concat(voc.title[0].lang, ";\n") +
                    "\tdct:description \"".concat(voc.description[0].value.replace('^', ';'), "\"@").concat(voc.description[0].lang.replace('^', ';'), ";\n") +
                    "\tskos:hasTopConcept";
            var stout = header;
            if (voc_filename) {
                var data = csv_factory_1.CsvFactory.load(voc_filename, csvDelimiter_1, false);
                if (data && data.length > 0) {
                    console.log("Processing '".concat(voc_filename, "': ").concat(data.length, " records found"));
                    // initiation of variables for loop:
                    var actualDeep = 1;
                    var urlStack = [];
                    var nodesStack = [];
                    var bodyStack = [];
                    var nodeNodesStack = [];
                    var oldUrl = baseUrl;
                    var num = data.length;
                    urlStack.push(baseUrl);
                    for (var i = 0; i < num; i++) {
                        var d = data[i];
                        var deep = getNotationDeep(d.notation);
                        var deepNext = deep;
                        // check the deep of the next record
                        if ((i + 1) < num) {
                            var s = data[i + 1];
                            deepNext = getNotationDeep(s.notation);
                        }
                        else {
                            deepNext = 1;
                        }
                        if (deepNext === deep || deepNext < deep) {
                            oldUrl = urlStack[urlStack.length - 1];
                            var newUrl = "n1:".concat(d.id);
                            var body = "".concat(newUrl, "\n");
                            if (oldUrl === baseUrl)
                                body = "".concat(body, "\t a skos:Concept;\n") +
                                    "\tskos:inScheme ".concat(baseUrl, ";\n") +
                                    "\tskos:notation \"".concat(d.notation, "\";\n") +
                                    "\tskos:topConceptOf ".concat(oldUrl, ";\n") +
                                    "\tskos:prefLabel \"".concat(d.title.replace('^', ';'), "\"@").concat(voc.title[0].lang);
                            else
                                body = "".concat(body, "\t a skos:Concept;\n") +
                                    "\tskos:inScheme ".concat(baseUrl, ";\n") +
                                    "\tskos:notation \"".concat(d.notation, "\";\n") +
                                    "\tskos:broader ".concat(oldUrl, ";\n") +
                                    "\tskos:prefLabel \"".concat(d.title.replace('^', ';'), "\"@").concat(voc.title[0].lang);
                            if (d.description != "")
                                body = body + "; \n\tskos:description \"".concat(d.description.replace('^', ';'), "\"@").concat(voc.title[0].lang, ". \n");
                            else
                                body = body + ".\n";
                            nodesStack.push(newUrl);
                            stout = "".concat(stout).concat(body);
                            //In this case I have to write out the father with the nodesStack
                            if (deepNext < deep) {
                                nodeNodesStack.push(nodesStack);
                                var dif = deep - deepNext;
                                var _loop_1 = function () {
                                    urlStack.pop();
                                    var oldBody = bodyStack.pop();
                                    var nodesStack_1 = nodeNodesStack.pop();
                                    if (nodesStack_1 != undefined) {
                                        oldBody = "".concat(oldBody, ";\n") +
                                            "\tskos:narrower ";
                                        nodesStack_1.forEach(function (node) {
                                            oldBody = oldBody + "\n\t\t".concat(node, ",");
                                        });
                                        oldBody = oldBody === null || oldBody === void 0 ? void 0 : oldBody.replace(/.$/, ".");
                                        stout = "".concat(stout).concat(oldBody, "\n");
                                    }
                                    dif--;
                                };
                                while (dif > 0) {
                                    _loop_1();
                                }
                                // @ts-ignore
                                nodesStack = nodeNodesStack.pop();
                                actualDeep = deep;
                            }
                        }
                        else { /*If the deep of the next more than me. Actions:
                                    1. Store body of myself
                                    2. Store the actual nodesStack at nodeNodesStack
                                    3. Store the actual father
                                    4. Empty the nodesStack
                                    5. Store the actual deep
                                */
                            var oldUrl_1 = urlStack[urlStack.length - 1];
                            var newUrl = "n1:".concat(d.id);
                            var body = "".concat(newUrl, "\n");
                            if (oldUrl_1 === baseUrl)
                                body = "".concat(body, "\t a skos:Concept;\n") +
                                    "\tskos:inScheme ".concat(oldUrl_1, ";\n") +
                                    "\tskos:notation \"".concat(d.notation, "\";\n") +
                                    "\tskos:topConceptOf ".concat(oldUrl_1, ";\n") +
                                    "\tskos:prefLabel \"".concat(d.title.replace('^', ';'), "\"@").concat(voc.title[0].lang);
                            else
                                body = "".concat(body, "\t a skos:Concept;\n") +
                                    "\tskos:inScheme ".concat(baseUrl, ";\n") +
                                    "\tskos:notation \"".concat(d.notation, "\";\n") +
                                    "\tskos:broader ".concat(oldUrl_1, ";\n") +
                                    "\tskos:prefLabel \"".concat(d.title.replace('^', ';'), "\"@").concat(voc.title[0].lang);
                            if (d.description != "")
                                body = body + "; \n\tskos:description \"".concat(d.description.replace('^', ';'), "\"@").concat(voc.title[0].lang, " ");
                            bodyStack.push(body);
                            nodesStack.push(newUrl);
                            nodeNodesStack.push(nodesStack);
                            nodesStack = [];
                            urlStack.push(newUrl);
                            actualDeep = deep;
                        }
                    }
                    nodesStack.forEach(function (node) {
                        footer_1 = footer_1 + "\n\t\t".concat(node, ",");
                    });
                    footer_1 = footer_1.replace(/.$/, ".");
                    stout = "".concat(stout).concat(footer_1);
                    fs.writeFileSync(out_path, stout, { encoding: 'utf8' });
                }
                else {
                    console.log("\u001B[0;33mWARNING\u001B[0m Errors in file '".concat(voc_filename, "' - ignore"));
                }
            }
            else {
                console.log("\u001B[0;33mWARNING\u001B[0m file '".concat(data_folder, "/").concat(voc.id, ".csv' not found - ignore"));
            }
        }
    });
}
//# sourceMappingURL=csv2ttl.js.map